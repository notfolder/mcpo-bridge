# MCPO On-Demand MCP Bridge 詳細設計書

## 1. システム概要

### 1.1 目的

本システムは、OpenWebUI + MCPO 環境において、PowerPoint等の「ファイル生成系MCPサーバー」を数百人規模で安全に利用可能にすることを目的とする。

以下の要件を満たす：
- MCP/MCPOの同期モデルを維持
- マルチユーザー対応
- リソース分離の徹底
- 一時ファイルの確実な削除

### 1.2 背景と課題

既存のMCPサーバーは常駐プロセスを前提とした設計となっており、ファイル生成用途では以下の問題が発生する：

- メモリ常駐によるリソース消費
- 一時ファイルの肥大化
- ユーザー間での成果物混線リスク
- MCP仕様上、非同期ジョブやキューモデルが表現できない

本設計では、「1リクエスト = 1プロセス」という Ephemeral（短命）なプロセスモデルを採用することで、これらの課題を解決する。

### 1.3 設計の位置づけ

本設計は以下の特徴を持つ：

- MCP/MCPO仕様を逸脱しない正統な拡張
- 非同期・キューを導入せず、同期モデルを維持
- 「MCPサーバー = ジョブワーカー」という新しい解釈
- PowerPoint生成のような重いツール用途に特化した現実解

## 2. 要求仕様

### 2.1 機能要件

| ID | 要件 | 説明 |
|---|---|---|
| FR-1 | MCPO互換リクエスト受信 | MCPO仕様に準拠したMCPリクエストを受信し処理する |
| FR-2 | リクエスト毎プロセス起動 | 各リクエストに対して独立したMCPサーバープロセスを起動する |
| FR-3 | 単一リクエスト処理後終了 | MCPサーバーは1つのリクエストを処理した後、即座に終了する |
| FR-4 | ファイルダウンロード機能 | 生成されたファイルをHTTPS経由でダウンロード可能にする |
| FR-5 | ダウンロードURL有効期限 | ダウンロードURLに有効期限を設定し、期限後はアクセス不可とする |
| FR-6 | 自動ファイル削除 | 不要となったファイルを自動的に削除する |

### 2.2 非機能要件

| ID | 要件 | 説明 |
|---|---|---|
| NFR-1 | 高同時実行性 | 数百の同時リクエストに耐える処理能力を持つ |
| NFR-2 | ユーザー分離 | ユーザー間で成果物が完全に分離される |
| NFR-3 | プロトコル準拠 | MCP/MCPOプロトコル仕様に完全準拠する |
| NFR-4 | ステートレス設計 | 実装はステートレスを基本とし、水平スケール可能とする |

## 3. アーキテクチャ設計

### 3.1 全体構成

システムは以下のコンポーネントから構成される：

#### 論理構成図

```
OpenWebUI (Docker Container)
   |
   | MCP / MCPO (JSON-RPC over HTTP)
   | Port: 8080
   v
MCPO On-Demand Bridge (Docker Container)
   |
   | per-request subprocess
   |   - 作業ディレクトリ作成 (/tmp/mcpo-jobs/job-uuid)
   |   - MCP Server プロセス起動
   v
Ephemeral MCP Server Process
   |
   | ファイル生成 (pptx, pdf, etc.)
   v
Temporary File Store (Volume Mount)
   |
   | HTTPS download URL
   | Port: 8080 (Bridge経由)
   v
User Browser
```

#### Docker構成

- OpenWebUIコンテナとMCPO Bridgeコンテナが同一Docker Composeで管理される
- コンテナ間通信はDockerネットワーク経由
- 一時ファイルはDocker Volumeで永続化
- 両コンテナは同時起動・停止される

### 3.2 デプロイメント構成

#### 開発環境
- Docker Compose による単一ホスト構成
- OpenWebUIとMCPO Bridgeが同一ネットワーク上で動作
- ローカルボリュームを使用した一時ファイル管理

#### 本番環境（想定）
- Kubernetes等のオーケストレーターによる複数ホスト構成
- ロードバランサー配下での水平スケール
- 共有ストレージ（NFS、S3等）による一時ファイル管理

## 4. コンポーネント詳細設計

### 4.1 MCPO On-Demand Bridge

#### 4.1.1 役割と責務

Bridgeコンポーネントは以下の責務を持つ：

- MCPOエンドポイントの提供
- リクエスト受信とバリデーション
- ジョブIDの発行と管理
- 作業ディレクトリの作成と権限設定
- MCPサーバープロセスの起動と監視
- プロセスとの標準入出力通信
- 処理完了まで同期ブロック
- ダウンロードURL生成
- MCPO形式でのレスポンス返却
- 静的ファイル配信機能

#### 4.1.2 技術スタック

- 実装言語：Python 3.11以上
- Webフレームワーク：FastAPI
- 非同期処理：asyncio
- プロセス管理：subprocess モジュール
- HTTPサーバー：Uvicorn
- Docker基盤：Alpine Linux ベースイメージ

#### 4.1.3 主要モジュール構成

システムは以下のモジュールで構成される：

##### エンドポイントモジュール
- MCPOプロトコルエンドポイントの実装
- JSON-RPC over HTTPリクエストの受信
- リクエストバリデーション
- レスポンス生成とシリアライズ

##### ジョブ管理モジュール
- UUID v4 によるジョブID発行
- ジョブメタデータの管理（作成時刻、有効期限、状態）
- ジョブディレクトリの作成と権限設定
- ジョブ状態の追跡

##### プロセス実行モジュール
- MCPサーバープロセスの起動
- 標準入出力パイプの管理
- プロセス監視とタイムアウト処理
- プロセス終了待機と同期ブロック
- 標準出力からのJSON解析
- エラーハンドリングと例外処理

##### ファイル配信モジュール
- 静的ファイル配信エンドポイント
- ダウンロードURL生成（job-uuid含む）
- 有効期限チェック
- ファイルストリーミング送信
- Content-Typeヘッダー設定

##### ガーベジコレクションモジュール
- 定期的な期限切れファイル検査
- ディレクトリ削除処理
- 起動時の孤児ディレクトリクリーンアップ
- 安全な削除処理（パス検証）

##### 設定管理モジュール
- MCPサーバー設定ファイル読み込み
- JSON形式設定パース
- 環境変数からの設定オーバーライド
- 設定バリデーション

#### 4.1.4 MCPサーバー設定仕様

BridgeはClaude等で使用されるMCPサーバー設定JSON形式を使用する。

##### 設定ファイル構造

設定ファイルは以下の構造を持つ：

- ルートオブジェクトに「mcpServers」キーが存在
- 各サーバー定義はサーバー名をキーとするオブジェクト
- サーバー定義には「command」と「args」が必須
- 「env」キーでサーバー固有の環境変数を指定可能

##### サーバー定義の要素

各MCPサーバー定義には以下が含まれる：

- command：実行するコマンドパス（絶対パスまたは相対パス）
- args：コマンドライン引数の配列
- env：環境変数のキーバリューマップ（オプショナル）

##### 作業ディレクトリの指定方法

MCPサーバーに作業ディレクトリを渡すには以下の方法を使用：

- args配列内に特殊トークン「__WORKDIR__」を記述
- Bridge実行時に実際のジョブディレクトリパスに置換される
- 環境変数による指定も可能（MCPO_WORKDIR等）

##### 設定ファイルの配置

- コンテナ内パス：/app/config/mcp-servers.json
- Docker Volumeまたは ConfigMapでマウント
- 設定変更時はコンテナ再起動が必要

#### 4.1.5 並行実行制御

同時実行制御のため以下を実装：

- asyncio.Semaphore による同時起動プロセス数制限
- デフォルト上限：CPU コア数 × 4
- 環境変数による上限カスタマイズ可能
- 上限到達時は429 Too Many Requests を返却

#### 4.1.6 タイムアウト設定

プロセス実行のタイムアウト管理：

- デフォルトタイムアウト：300秒（5分）
- 環境変数による調整可能
- タイムアウト時はプロセス強制終了（SIGTERM → SIGKILL）
- クライアントには504 Gateway Timeout を返却

### 4.2 Ephemeral MCP Server

#### 4.2.1 特性と要件

Ephemeral（短命）MCPサーバーは以下の特性を持つ：

- 1リクエスト = 1プロセスの原則
- 起動時に作業ディレクトリを引数または環境変数で受け取る
- 標準入力からMCPリクエストJSONを読み取る
- 標準出力にMCPレスポンスJSONを出力
- 処理完了後は即座にプロセス終了（exit code 0）
- エラー時は標準エラー出力にメッセージ出力後、非ゼロで終了

#### 4.2.2 実装条件

MCPサーバー実装は以下を満たす必要がある：

- MCP標準仕様に準拠したJSON-RPC通信
- ファイル出力先を引数で指定可能な設計
- ステートレスな処理（前回実行結果に依存しない）
- 適切なエラーハンドリングと終了コード
- タイムアウト内での処理完了

#### 4.2.3 対応MCPサーバー例

以下のようなMCPサーバーが利用可能：

- PowerPoint生成サーバー（pptx-mcp-server 等）
- PDF生成サーバー
- Excel生成サーバー
- 画像生成サーバー
- その他ファイル生成系MCPサーバー

### 4.3 一時ファイル管理

#### 4.3.1 ディレクトリ構造

一時ファイルは以下の構造で管理される：

```
/tmp/mcpo-jobs/
  └── {job-uuid}/
       ├── request.json      # 受信したMCPリクエスト
       ├── response.json     # MCPサーバーからのレスポンス
       ├── metadata.json     # ジョブメタデータ
       ├── output.pptx       # 生成ファイル（例）
       └── server.log        # MCPサーバーログ（オプション）
```

#### 4.3.2 ディレクトリライフサイクル

各ジョブディレクトリは以下のライフサイクルを持つ：

- 作成：リクエスト受信時、chmod 700で作成
- 利用：MCPサーバープロセスによるファイル生成
- 保持：処理完了後も一定期間保持（デフォルト1時間）
- 削除：有効期限切れ後、ガーベジコレクタにより削除

#### 4.3.3 メタデータ管理

metadata.jsonには以下の情報を記録：

- job_id：ジョブの一意識別子
- created_at：作成日時（ISO 8601形式）
- expires_at：有効期限（ISO 8601形式）
- server_name：使用したMCPサーバー名
- status：ジョブ状態（processing, completed, failed）
- output_files：生成されたファイル一覧

#### 4.3.4 セキュリティ考慮

ファイルセキュリティのため以下を実施：

- ジョブディレクトリは700パーミッション（所有者のみアクセス可）
- job-uuidは推測困難なUUID v4を使用
- 親ディレクトリ（/tmp/mcpo-jobs）も700パーミッション
- シンボリックリンク攻撃対策（パス正規化チェック）

#### 4.3.5 Docker Volume設計

Docker環境では以下のVolume設計を採用：

- 名前付きVolume「mcpo-jobs」を使用
- コンテナ内マウントポイント：/tmp/mcpo-jobs
- ホスト側パスは Docker が自動管理
- 開発環境ではバインドマウントも選択可能

## 5. 処理フロー設計

### 5.1 正常系処理シーケンス

#### 全体フロー

1. OpenWebUIからMCPOリクエスト送信
2. Bridge でリクエスト受信・バリデーション
3. UUID によるジョブID発行
4. ジョブディレクトリ作成（/tmp/mcpo-jobs/{job-uuid}/）
5. メタデータファイル作成
6. リクエストJSONをファイル保存
7. MCPサーバー設定から対象サーバー選択
8. コマンドライン引数組み立て（__WORKDIR__置換）
9. MCPサーバープロセス起動
10. 標準入力にリクエスト送信
11. 標準出力からレスポンス読み取り（同期ブロック）
12. プロセス終了待機
13. 生成ファイル確認
14. ダウンロードURL生成
15. メタデータ更新（status=completed）
16. MCPOレスポンス組み立て
17. クライアントへレスポンス返却

#### リクエスト処理の詳細フロー

##### Phase 1: リクエスト受付

- HTTPリクエストボディからJSON抽出
- JSON-RPCフォーマット検証
- メソッド名とパラメータの妥当性確認
- 対応MCPサーバーの存在確認

##### Phase 2: ジョブ準備

- UUID v4生成
- 現在時刻取得
- 有効期限計算（現在時刻 + 設定値）
- ジョブディレクトリ作成
- パーミッション設定（700）
- メタデータJSON作成

##### Phase 3: プロセス実行

- MCPサーバー設定読み込み
- コマンド構築（パス置換処理）
- 環境変数準備
- subprocess.Popen でプロセス起動
- 標準入力へリクエストJSON書き込み
- 標準出力からレスポンスJSON読み取り
- タイムアウト監視
- プロセス終了コード確認

##### Phase 4: レスポンス処理

- 生成ファイル検索（ディレクトリスキャン）
- ファイル情報取得（サイズ、MIME type）
- ダウンロードURL組み立て
- MCPレスポンスJSON構築
- メタデータ更新
- HTTPレスポンス返却

### 5.2 異常系処理フロー

#### タイムアウト発生時

1. タイムアウト検出
2. MCPサーバープロセスにSIGTERM送信
3. 10秒待機
4. まだ終了していなければSIGKILL送信
5. エラーログ記録
6. ジョブステータスを「failed」に更新
7. クライアントに504エラー返却

#### MCPサーバー異常終了時

1. 非ゼロ終了コード検出
2. 標準エラー出力取得
3. エラーログ記録
4. ジョブステータスを「failed」に更新
5. エラーメッセージ抽出
6. クライアントに500エラーとエラー詳細を返却

#### ファイル生成失敗時

1. プロセスは正常終了したがファイルが存在しない
2. ディレクトリ内容確認
3. MCPレスポンス内容確認
4. エラーログ記録
5. ジョブステータスを「failed」に更新
6. クライアントに500エラー返却

#### 並行実行制限到達時

1. Semaphore 取得試行
2. 即座に取得できない場合
3. リトライせず429エラー返却
4. Retry-Afterヘッダー付与
5. クライアント側でリトライ推奨

#### ディスク容量不足時

1. ファイル書き込み時にOSError検出
2. エラーログ記録
3. 部分的に作成されたファイル削除
4. ジョブディレクトリ削除
5. クライアントに507エラー返却

### 5.3 ファイルダウンロードフロー

#### ダウンロードリクエスト処理

1. ダウンロードURLにアクセス（GET /files/{job-uuid}/{filename}）
2. job-uuid抽出
3. ジョブディレクトリ存在確認
4. metadata.json読み込み
5. 有効期限チェック
6. ファイルパス構築
7. パストラバーサル攻撃チェック
8. ファイル存在確認
9. MIME type判定
10. Content-Dispositionヘッダー設定
11. ファイルストリーミング送信

#### 有効期限切れ時

1. expires_at と現在時刻を比較
2. 期限切れの場合404 Not Found返却
3. クライアントにメッセージ表示
4. 後続のGC処理でファイル削除

#### セキュリティチェック

- ファイル名にディレクトリトラバーサル文字列がないか確認（../ 等）
- job-uuid が有効なUUID形式か検証
- ジョブディレクトリが/tmp/mcpo-jobs配下か確認
- シンボリックリンクでないか確認

## 6. API仕様設計

### 6.1 MCPOエンドポイント

#### エンドポイント仕様

- メソッド：POST
- パス：/mcp
- Content-Type：application/json
- プロトコル：JSON-RPC 2.0

#### リクエスト形式

JSON-RPC 2.0形式のリクエストを受け付ける：

- jsonrpc：バージョン文字列（固定値「2.0」）
- method：呼び出すツール名（MCPサーバーで定義されたツール）
- params：ツールパラメータオブジェクト
- id：リクエストID（数値または文字列）

#### レスポンス形式（成功時）

JSON-RPC 2.0成功レスポンス：

- jsonrpc：バージョン文字列（固定値「2.0」）
- result：ツール実行結果オブジェクト
  - file_name：生成されたファイル名
  - download_url：ダウンロードURL（完全修飾URL）
  - expires_at：有効期限（ISO 8601形式日時文字列）
  - file_size：ファイルサイズ（バイト数）
  - mime_type：MIMEタイプ
- id：リクエストIDのエコーバック

#### レスポンス形式（エラー時）

JSON-RPC 2.0エラーレスポンス：

- jsonrpc：バージョン文字列（固定値「2.0」）
- error：エラーオブジェクト
  - code：エラーコード（JSON-RPC標準またはカスタム）
  - message：エラーメッセージ
  - data：追加エラー情報（オプショナル）
- id：リクエストIDのエコーバック（またはnull）

#### エラーコード定義

システムで使用するエラーコード：

- -32700：Parse error（JSON解析エラー）
- -32600：Invalid Request（リクエスト形式不正）
- -32601：Method not found（メソッド存在せず）
- -32602：Invalid params（パラメータ不正）
- -32603：Internal error（内部エラー）
- -32000：Server error（MCPサーバーエラー）
- -32001：Timeout error（タイムアウト）
- -32002：Resource limit（リソース制限）

### 6.2 ファイルダウンロードエンドポイント

#### エンドポイント仕様

- メソッド：GET
- パス：/files/{job-uuid}/{filename}
- 認証：不要（URLが秘密情報）
- レスポンス：バイナリストリーム

#### パスパラメータ

- job-uuid：ジョブ識別子（UUID v4形式）
- filename：ダウンロードするファイル名

#### レスポンスヘッダー

- Content-Type：ファイルのMIMEタイプ
- Content-Disposition：attachment; filename="..."
- Content-Length：ファイルサイズ
- Cache-Control：no-cache
- Expires：有効期限日時

#### ステータスコード

- 200 OK：ダウンロード成功
- 404 Not Found：ファイル不在または期限切れ
- 403 Forbidden：アクセス権限なし
- 500 Internal Server Error：サーバーエラー

### 6.3 ヘルスチェックエンドポイント

#### エンドポイント仕様

- メソッド：GET
- パス：/health
- レスポンス：JSON

#### レスポンス内容

- status：健全性ステータス（ok / degraded / down）
- timestamp：チェック実行時刻
- version：Bridgeバージョン
- uptime：稼働時間（秒）

#### 判定基準

- 正常：すべてのコンポーネントが動作中
- 劣化：一部リソースが制限に近い
- 停止：重大な問題発生

## 7. データ設計

### 7.1 メタデータ構造

#### metadata.json スキーマ

各ジョブディレクトリに配置されるメタデータファイルの構造：

- job_id（string）：ジョブ一意識別子
- server_name（string）：使用したMCPサーバー名
- created_at（string）：作成日時（ISO 8601）
- expires_at（string）：有効期限（ISO 8601）
- status（string）：ジョブ状態（processing / completed / failed）
- request（object）：受信したMCPリクエスト
- response（object）：MCPサーバーレスポンス（処理完了後）
- error（string）：エラーメッセージ（失敗時のみ）
- output_files（array）：生成ファイル情報配列
  - filename（string）：ファイル名
  - size（number）：サイズ（バイト）
  - mime_type（string）：MIMEタイプ

### 7.2 設定ファイル構造

#### mcp-servers.json スキーマ

MCPサーバー設定ファイルの構造：

- mcpServers（object）：サーバー定義マップ
  - {server-name}（object）：個別サーバー設定
    - command（string）：実行コマンドパス
    - args（array of string）：コマンドライン引数
    - env（object）：環境変数マップ（オプショナル）

#### 特殊トークン

args配列内で使用可能な特殊トークン：

- __WORKDIR__：ジョブ作業ディレクトリパスに置換される
- __JOB_ID__：ジョブUUIDに置換される

### 7.3 環境変数設計

#### Bridge設定用環境変数

- MCPO_CONFIG_FILE：MCP設定ファイルパス（デフォルト：/app/config/mcp-servers.json）
- MCPO_JOBS_DIR：ジョブディレクトリルート（デフォルト：/tmp/mcpo-jobs）
- MCPO_BASE_URL：ダウンロードURL用ベースURL（デフォルト：http://localhost:8080）
- MCPO_FILE_EXPIRY：ファイル有効期限（秒）（デフォルト：3600）
- MCPO_MAX_CONCURRENT：最大同時実行数（デフォルト：CPU数×4）
- MCPO_TIMEOUT：プロセスタイムアウト（秒）（デフォルト：300）
- MCPO_LOG_LEVEL：ログレベル（デフォルト：INFO）

#### MCPサーバー実行時環境変数

MCPサーバープロセスに渡される環境変数：

- MCPO_WORKDIR：作業ディレクトリパス
- MCPO_JOB_ID：ジョブID
- その他、mcp-servers.jsonのenv設定

## 8. セキュリティ設計

### 8.1 認証・認可

#### 現行方式

- MCPOエンドポイントは認証なし（OpenWebUIからの内部通信想定）
- ダウンロードURLによる暗黙的な認可（UUID知識ベース）
- Dockerネットワーク分離による外部アクセス制限

#### 将来拡張（オプション）

- APIキーによる認証
- OpenWebUIセッショントークン連携
- ダウンロードURLへの署名付与

### 8.2 入力検証

#### リクエストバリデーション

- JSON-RPCフォーマット厳密検証
- メソッド名ホワイトリスト照合
- パラメータ型・必須チェック
- パラメータ値範囲検証

#### パス検証

- ジョブディレクトリパス正規化
- 親ディレクトリトラバーサル防止
- シンボリックリンク検出
- ホワイトリストベースパス検証

#### ファイル名検証

- 許可文字制限（英数字、ハイフン、アンダースコア、ドット）
- 長さ制限（255バイト以内）
- 拡張子ホワイトリスト照合

### 8.3 プロセス分離

#### 実行権限

- Bridgeプロセスは非rootユーザーで実行
- MCPサーバープロセスも非rootユーザーで実行
- ユーザーIDはDockerfileで固定

#### リソース制限

- 各MCPサーバープロセスにCPU制限設定（オプション）
- メモリ上限設定（オプション）
- ディスク使用量監視（将来実装）

### 8.4 ファイルシステムセキュリティ

#### パーミッション設計

- /tmp/mcpo-jobs：700（所有者のみアクセス）
- /tmp/mcpo-jobs/{job-uuid}：700
- 生成ファイル：600（所有者のみ読み書き）

#### 削除ポリシー

- 有効期限切れファイルの確実な削除
- 削除失敗時のリトライ機構
- 削除ログ記録

### 8.5 Docker セキュリティ

#### イメージセキュリティ

- 公式Pythonイメージをベースに使用
- 最小限のパッケージインストール
- 定期的なイメージ更新
- 脆弱性スキャン実施

#### ランタイムセキュリティ

- read-onlyルートファイルシステム（/tmp除く）
- no-new-privileges設定
- capabilitiesドロップ
- seccompプロファイル適用

#### ネットワークセキュリティ

- 内部ネットワーク分離
- 不要ポート非公開
- TLS通信（本番環境）

## 9. スケーラビリティ設計

### 9.1 垂直スケール（単一インスタンス）

#### CPU拡張

- マルチコアCPUによる並列処理
- asyncioによる非同期I/O活用
- Semaphoreによる並行数最適化

#### メモリ拡張

- ファイルストリーミング送信によるメモリ節約
- ジョブメタデータの軽量化
- 不要オブジェクトの早期解放

#### ストレージ拡張

- ボリュームサイズ拡張
- 古いファイルの積極的削除
- ストレージ使用量監視

### 9.2 水平スケール（複数インスタンス）

#### ステートレス設計

- インスタンス間で状態共有なし
- セッション情報なし
- ジョブIDによる一意性担保

#### ロードバランシング

- ラウンドロビン分散
- ヘルスチェック連動
- セッションアフィニティ不要

#### 共有ストレージ

- NFS、Ceph、S3等の利用
- 全インスタンスが同一ストレージアクセス
- ダウンロードリクエストはどのインスタンスでも処理可能

### 9.3 データベース不使用設計

#### ファイルベース管理の利点

- 外部依存なし
- セットアップ簡易
- 障害点削減

#### スケール制約

- 大規模環境では共有ストレージが必要
- メタデータ検索性能限界
- 将来的にはDB導入も検討

### 9.4 性能目標

#### レスポンスタイム

- MCPリクエスト受信からレスポンス返却まで：平均5秒以内
- ファイルダウンロード開始まで：1秒以内

#### スループット

- 単一インスタンス：10リクエスト/秒
- 複数インスタンス：100リクエスト/秒以上

#### 同時接続数

- 単一インスタンス：50並行処理
- 複数インスタンス：500並行処理以上

## 10. ガーベジコレクション設計

### 10.1 削除対象の判定

#### 期限切れジョブ

- metadata.jsonのexpires_at参照
- 現在時刻と比較
- 期限切れジョブを削除対象としてマーク

#### 孤児ディレクトリ

- metadata.jsonが存在しないディレクトリ
- 作成から一定時間経過（デフォルト24時間）
- 異常終了等で残存したディレクトリ

### 10.2 削除タイミング

#### 定期実行（cron方式）

- 実行間隔：5分毎（デフォルト）
- バックグラウンドタスクとして実行
- asyncioスケジューラー利用

#### 起動時クリーンアップ

- Bridge起動時に1回実行
- 前回異常終了時の残存ファイル削除
- 整合性確保

### 10.3 削除処理フロー

#### Phase 1: スキャン

1. /tmp/mcpo-jobs ディレクトリ走査
2. 各ジョブディレクトリのmetadata.json読み込み
3. expires_at確認
4. 削除対象リスト作成

#### Phase 2: 削除実行

1. 削除対象ディレクトリに対して順次処理
2. ディレクトリ内全ファイル削除
3. ディレクトリ自体を削除
4. 削除成功ログ記録

#### Phase 3: エラーハンドリング

1. 削除失敗時はログ記録
2. 次回GC実行時にリトライ
3. 連続失敗時はアラート（将来実装）

### 10.4 安全性担保

#### パス検証

- 削除対象が/tmp/mcpo-jobs配下か厳密確認
- 親ディレクトリ削除防止
- シンボリックリンク追跡禁止

#### ロック機構

- 削除中ディレクトリへのアクセス防止（オプション）
- ファイルロック利用
- 削除フラグファイル配置

#### ログ記録

- 削除ジョブID記録
- 削除日時記録
- エラー詳細記録

## 11. エラーハンドリング設計

### 11.1 エラー分類

#### レベル1：リクエストエラー

- クライアント起因のエラー
- 4xxステータスコード
- リトライ不要

#### レベル2：処理エラー

- MCPサーバー起因のエラー
- 5xxステータスコード
- リトライ可能な場合あり

#### レベル3：システムエラー

- Bridge自体の障害
- 503ステータスコード
- リトライ推奨

### 11.2 エラーレスポンス設計

#### 統一フォーマット

すべてのエラーレスポンスは以下を含む：

- errorコード（JSON-RPC準拠）
- errorメッセージ（人間可読）
- 詳細情報（スタックトレースは非本番のみ）
- リトライ可否フラグ
- 推奨待機時間

### 11.3 ログ設計

#### ログレベル

- DEBUG：デバッグ情報
- INFO：通常動作ログ
- WARNING：警告（処理は継続）
- ERROR：エラー（処理失敗）
- CRITICAL：致命的エラー（サービス停止）

#### ログ出力先

- 標準出力（Dockerログに集約）
- 本番環境では外部ログ集約サービス連携

#### ログフォーマット

- JSON形式
- タイムスタンプ、ログレベル、メッセージ、コンテキスト情報含む
- トレースIDによるリクエスト追跡

### 11.4 監視・アラート設計

#### 監視項目

- エラー発生率
- レスポンスタイム
- 同時実行数
- ディスク使用率
- プロセス起動失敗率

#### アラート条件

- エラー率閾値超過
- レスポンスタイム劣化
- ディスク容量逼迫
- 連続処理失敗

## 12. Docker化設計

### 12.1 Dockerfile設計方針

#### ベースイメージ

- 公式Pythonイメージ使用（python:3.11-slim）
- Alpine Linuxも選択肢（軽量化優先時）
- セキュリティアップデート適用済みイメージ選定

#### マルチステージビルド

- ビルドステージ：依存関係インストール
- 実行ステージ：最小限のファイルのみコピー
- イメージサイズ削減

#### レイヤー最適化

- 変更頻度の低いコマンドを先に配置
- キャッシュ効率最大化
- 不要ファイル除外

### 12.2 実行ユーザー設計

#### 非rootユーザー実行

- 専用ユーザー「mcpobridge」作成
- UID/GID：1000:1000
- セキュリティベストプラクティス準拠

#### ファイル所有権

- アプリケーションファイルはmcpobridgeが所有
- /tmp/mcpo-jobsもmcpobridge所有
- 適切なパーミッション設定

### 12.3 ボリューム設計

#### 一時ファイルボリューム

- ボリューム名：mcpo-jobs
- マウントポイント：/tmp/mcpo-jobs
- 永続化ストレージ

#### 設定ファイルボリューム

- ボリューム名：mcpo-config
- マウントポイント：/app/config
- 読み取り専用マウント

#### ログボリューム（オプション）

- ボリューム名：mcpo-logs
- マウントポイント：/app/logs
- 永続化ログ保存

### 12.4 ネットワーク設計

#### 内部ネットワーク

- ネットワーク名：mcpo-network
- ドライバー：bridge
- OpenWebUIとBridgeが接続

#### ポート公開

- Bridgeポート：8080
- OpenWebUIからのみアクセス可能
- ホストへの公開は不要（OpenWebUI経由）

### 12.5 環境変数設計

#### 必須環境変数

- MCPO_BASE_URL：ダウンロードURL生成用
- 例：http://mcpo-bridge:8080

#### オプション環境変数

- MCPO_FILE_EXPIRY：ファイル有効期限
- MCPO_MAX_CONCURRENT：最大同時実行数
- MCPO_TIMEOUT：タイムアウト時間
- MCPO_LOG_LEVEL：ログレベル

### 12.6 ヘルスチェック設計

#### Dockerヘルスチェック

- チェック方法：HTTP GET /health
- 間隔：30秒
- タイムアウト：10秒
- リトライ：3回
- 開始遅延：10秒

#### ヘルスチェック判定

- 成功：200 OK応答
- 失敗：タイムアウトまたは非200応答
- unhealthy判定後の動作：Docker依存

## 13. Docker Compose設計

### 13.1 サービス定義

#### OpenWebUIサービス

- サービス名：openwebui
- イメージ：公式OpenWebUIイメージ
- ポート：ホスト3000 → コンテナ8080
- ボリューム：openwebui-data（永続化）
- ネットワーク：mcpo-network
- 依存関係：mcpo-bridge（depends_on）

#### MCPO Bridgeサービス

- サービス名：mcpo-bridge
- ビルド：ローカルDockerfile使用
- ポート：コンテナ8080（内部のみ）
- ボリューム：mcpo-jobs、mcpo-config
- ネットワーク：mcpo-network
- ヘルスチェック：有効

### 13.2 ボリューム定義

#### 名前付きボリューム

- openwebui-data：OpenWebUIデータ永続化
- mcpo-jobs：Bridge一時ファイル
- mcpo-config：MCP設定ファイル

#### バインドマウント（開発環境）

- ./config:/app/config：設定ファイル編集容易化
- ./logs:/app/logs：ログ確認容易化

### 13.3 ネットワーク定義

#### mcpo-network

- ドライバー：bridge
- 内部通信専用
- DNSによるサービス名解決

### 13.4 環境変数設定

#### OpenWebUI環境変数

- OPENAI_API_BASE：MCPOエンドポイント指定
- 値：http://mcpo-bridge:8080/mcp

#### MCPO Bridge環境変数

- MCPO_BASE_URL：http://mcpo-bridge:8080
- MCPO_CONFIG_FILE：/app/config/mcp-servers.json
- その他設定値

### 13.5 起動順序制御

#### depends_on設定

- OpenWebUIはmcpo-bridgeに依存
- mcpo-bridgeのhealthy確認後にOpenWebUI起動
- condition: service_healthy 利用

#### 起動シーケンス

1. ネットワーク作成
2. ボリューム作成
3. mcpo-bridge起動
4. mcpo-bridgeヘルスチェック待機
5. openwebui起動
6. システム利用可能

### 13.6 開発環境と本番環境の差異

#### 開発環境

- バインドマウント多用
- デバッグログレベル
- ホットリロード有効
- イメージビルドローカル実行

#### 本番環境

- 名前付きボリュームのみ
- INFOログレベル
- ホットリロード無効
- イメージレジストリから取得

### 13.7 docker-compose.ymlファイル設計

#### ファイル構成

- version：Compose file format version 3.8
- services：openwebui、mcpo-bridge
- volumes：ボリューム定義
- networks：ネットワーク定義

#### 設定項目詳細

各サービスには以下を設定：

- container_name：コンテナ識別名
- image またはbuild：イメージソース
- ports：ポートマッピング
- volumes：ボリュームマウント
- environment：環境変数
- networks：接続ネットワーク
- depends_on：依存関係
- healthcheck：ヘルスチェック設定
- restart：再起動ポリシー

#### 再起動ポリシー

- 開発環境：no または on-failure
- 本番環境：unless-stopped

### 13.8 運用コマンド

#### 起動コマンド

- docker-compose up -d：バックグラウンド起動
- docker-compose up：フォアグラウンド起動（ログ確認）

#### 停止コマンド

- docker-compose down：停止とコンテナ削除
- docker-compose stop：停止のみ

#### ログ確認

- docker-compose logs -f：全サービスログ追跡
- docker-compose logs -f mcpo-bridge：Bridgeのみ

#### 再ビルド

- docker-compose build：イメージ再ビルド
- docker-compose up -d --build：ビルド後起動

## 14. MCP設定ファイル詳細仕様

### 14.1 設定ファイル配置

#### ファイルパス

- デフォルト：/app/config/mcp-servers.json
- 環境変数で変更可能：MCPO_CONFIG_FILE

#### ファイル形式

- エンコーディング：UTF-8
- フォーマット：JSON
- スキーマバリデーション：起動時実施

### 14.2 設定ファイル構造詳細

#### ルートオブジェクト

- mcpServers：サーバー定義マップ（必須）
- version：設定ファイルバージョン（オプション、将来用）
- defaults：全サーバー共通のデフォルト設定（オプション）

#### サーバー定義オブジェクト

各サーバーは以下のフィールドを持つ：

- command：実行バイナリパス（必須）
  - 絶対パスまたは相対パス
  - PATH環境変数で解決可能なコマンド名
- args：コマンドライン引数配列（必須、空配列可）
  - 文字列の配列
  - 特殊トークン置換対応
- env：環境変数マップ（オプション）
  - キーバリューペアのオブジェクト
  - サーバー実行時に設定
- timeout：タイムアウト秒数（オプション）
  - 個別サーバーのタイムアウト設定
  - グローバル設定を上書き

### 14.3 特殊トークン仕様

#### __WORKDIR__

- 用途：作業ディレクトリパス指定
- 置換内容：/tmp/mcpo-jobs/{job-uuid}
- 使用例：args配列内に"--output"、"__WORKDIR__"と記述

#### __JOB_ID__

- 用途：ジョブID指定
- 置換内容：job-uuid文字列
- 使用例：args配列内に"--job-id"、"__JOB_ID__"と記述

#### 置換タイミング

- MCPサーバープロセス起動直前
- args配列を走査して全トークンを置換
- 環境変数envには自動設定（MCPO_WORKDIR等）

### 14.4 設定例（参照）

本仕様書ではコード例を記載しないが、以下の構造を持つ設定が可能：

- 複数のMCPサーバーを定義
- 各サーバーは独自のcommand、args、envを持つ
- PowerPoint生成サーバー、PDF生成サーバー等を併用可能
- 作業ディレクトリは__WORKDIR__トークンで指定

### 14.5 設定バリデーション

#### 起動時検証

- JSON構文検証
- 必須フィールド存在確認
- フィールド型検証
- command実行可能性確認（警告のみ）

#### ランタイム検証

- リクエスト受信時、指定サーバー名の存在確認
- 存在しない場合はエラー返却

### 14.6 設定リロード

#### 現行仕様

- 設定ファイル変更時はBridge再起動が必要
- 動的リロード機能なし

#### 将来拡張

- SIGHUP シグナルによる設定リロード
- 設定ファイル監視と自動リロード

## 15. 運用設計

### 15.1 デプロイ手順

#### 初回デプロイ

1. リポジトリクローン
2. mcp-servers.json 作成・配置
3. docker-compose.yml 環境変数調整
4. docker-compose up -d 実行
5. ヘルスチェック確認
6. OpenWebUI アクセス確認

#### 更新デプロイ

1. 最新コードpull
2. docker-compose build 実行
3. docker-compose up -d --no-deps mcpo-bridge 実行
4. ヘルスチェック確認
5. 動作確認

### 15.2 監視項目

#### サービス監視

- コンテナ稼働状態
- ヘルスチェック結果
- リスタート回数

#### リソース監視

- CPU使用率
- メモリ使用量
- ディスク使用量（ボリューム）
- ネットワークトラフィック

#### アプリケーション監視

- リクエスト数
- エラー率
- レスポンスタイム
- 同時実行プロセス数

### 15.3 バックアップ

#### 対象データ

- mcp-servers.json 設定ファイル
- docker-compose.yml
- ボリュームデータ（オプション）

#### バックアップ頻度

- 設定ファイル：変更時
- ボリューム：不要（一時ファイルのみ）

### 15.4 障害対応

#### コンテナ再起動

- docker-compose restart mcpo-bridge
- 自動再起動ポリシーにより自動復旧も可能

#### ログ確認

- docker-compose logs mcpo-bridge
- エラー原因特定

#### ロールバック

- 前バージョンイメージへの切り戻し
- docker-compose down → イメージタグ変更 → up

### 15.5 スケールアウト

#### 手動スケール

- docker-compose up -d --scale mcpo-bridge=3
- ロードバランサー設定（別途必要）

#### Kubernetes移行

- Deployment マニフェスト作成
- Service、Ingress 設定
- PersistentVolumeClaim 設定

## 16. テスト設計

### 16.1 ユニットテスト

#### テスト対象

- リクエストバリデーション関数
- パス検証関数
- メタデータ生成関数
- トークン置換関数

#### テストフレームワーク

- pytest
- モックライブラリ使用

### 16.2 統合テスト

#### テストシナリオ

- エンドツーエンドMCPリクエスト処理
- ファイルダウンロード
- エラーハンドリング
- タイムアウト処理

#### テスト環境

- Docker Compose によるテスト環境構築
- モックMCPサーバー使用

### 16.3 負荷テスト

#### テストツール

- Apache Bench (ab)
- Locust
- k6

#### テスト項目

- 同時リクエスト数増加
- レスポンスタイム測定
- エラー率測定

### 16.4 セキュリティテスト

#### テスト項目

- パストラバーサル攻撃
- 不正リクエスト送信
- リソース枯渇攻撃

#### テストツール

- 手動テスト
- OWASP ZAP（オプション）

## 17. 今後の拡張

### 17.1 短期拡張（Phase 2）

- 認証機能追加
- ダウンロードURL署名
- メトリクス収集（Prometheus対応）
- トレーシング（OpenTelemetry対応）

### 17.2 中期拡張（Phase 3）

- データベース導入（ジョブ管理）
- 管理UI提供
- ジョブ一覧・検索機能
- ユーザー別クォータ管理

### 17.3 長期拡張（Phase 4）

- 非同期ジョブキュー（オプション機能）
- マルチリージョン対応
- オブジェクトストレージ連携（S3等）
- Webhook通知機能

## 18. 付録

### 18.1 用語集

- MCP：Model Context Protocol
- MCPO：MCP over HTTP の通称
- Ephemeral：短命、一時的
- GC：Garbage Collection（ガーベジコレクション）
- UUID：Universally Unique Identifier

### 18.2 参考資料

- MCP公式仕様書
- FastAPI公式ドキュメント
- Docker公式ドキュメント
- JSON-RPC 2.0仕様

### 18.3 変更履歴

- 2026-01-17：初版作成
  - 全セクション詳細設計完了
  - Docker化設計追加
  - Docker Compose設計追加

---

本詳細設計書は、MCPO On-Demand MCP Bridgeシステムの実装に必要な全ての設計情報を網羅している。本設計に基づき実装を進めることで、安全でスケーラブルなファイル生成系MCPサーバー基盤を構築できる。
